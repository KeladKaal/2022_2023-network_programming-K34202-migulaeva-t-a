University: ITMO University

Faculty: FICT

Course: Network programming

Year: 2022

Group: K34202

Author: Migulaeva Tatyana Alekseevna

Lab: Lab4

Date of create: 19.10.2022

Ход работы:

1. Устанавливаем Vagrant для запуска необходимой виртуальной мшаины. Проверяем, что он установлен и работает корректно.
![image](https://user-images.githubusercontent.com/64036217/196666092-6de102d8-ac51-46b0-a1e2-5a9c28403cdb.png)

2. Клонируем репозиторий с заданиями, заходим в папку виртуальной машины, поднимаем её при помощи команды vagrant up.
![image](https://user-images.githubusercontent.com/64036217/196666732-0f4b47db-11b3-4e92-83de-d65059b077ea.png)

3. Открываем интерфейс виртуальной машины, заходим в аккаунт пользователя p4.
![image](https://user-images.githubusercontent.com/64036217/196666872-fde2cc03-603c-432e-a2ae-bb3d758796e5.png)

4. Далее в терминале заходим в папку первого задания, где видим файл basic.p4. По условию задачи в дальнейшем будет необходимо дописать его до работоспособного состояния, но в данный момент проверям, что mininet апускается и работает.
![image](https://user-images.githubusercontent.com/64036217/196667717-befbd70a-e07d-4b53-9f5b-e594398f243d.png)

5. Теперь необходимо дописать программу так, чтобы между роутерами шёл пинг. Поскольку у меня нет опыта работы с С, а опыт работы с С++ покрылся пылью, планирую в дальнейшем разобрать все основные моменты кода. Схема сети выглядит следующим образом. ИДея задачи состоит в том, чтобы при пересылке IPv4 коммутатор выполнял следующие действия для каждого пакета: обновление MAC-адреса источника и получателя, уменьшение TTL в заголовке IP и пересылка пакета из соответствующего порта.

Коммутатор имеет единую таблицу, которую при помощи P4 нужно заполнить правилами. Каждое правило сопоставляет IP-адрес с MAC-адресом и выходным портом для следующей пересылки. Вся инфраструктура уже реализована, необходимо дописать только правила, по которым необходимо работать с пакетом.
6. ![image](https://user-images.githubusercontent.com/64036217/196674117-008da439-fcf9-4eea-a7a2-a03b029f3b41.png)

7. В самом начале видим подключение двух библиотек, а также задание константы. Первая библиотека - это основная библиотека P4, в которой объявляются встроенные конструкции P4. v1model необходима для работы со свичами, которые даны по условию. Далее задаётся константа длиной в 16 бит с названием TYPE_IPV4.
![image](https://user-images.githubusercontent.com/64036217/196668455-e1d526ca-ddd1-425a-8ece-2590cfa93bf3.png)

7. Далее в заголовках видим создание ещё нескольких типов переменных.
![image](https://user-images.githubusercontent.com/64036217/196673966-14048f32-cd58-4bc3-b945-924fe3addcaa.png)

8. Далее прописано, из чего состоит пакет ethernet - в данном случае задаются мак адреса отправителя и получателя, а также тип кадра. 
![image](https://user-images.githubusercontent.com/64036217/196740369-af469292-bb06-4b1a-9c5c-fa3e08936a3a.png)

9. После кадра ethernet задаётся заголовок ipv4. Все указанные переменные соответствуют полям заголовка.
![image](https://user-images.githubusercontent.com/64036217/196903161-2ab716de-aff5-4f2b-9b3d-e4ba4aa5d115.png)

![image](https://user-images.githubusercontent.com/64036217/196903018-7d0336e8-544f-4037-b9fa-e4fa66c0bb07.png)

10. Поле метадата оставим пустым, так как это учебный проект и нет необходимости что-либо документировать там. Далее задаются те типы, которые были описаны ранее - ethernet и ipv4.
![image](https://user-images.githubusercontent.com/64036217/196903854-a2d61b6b-6b1d-4ce8-8c23-380e88987c22.png)

11. Далее переходим к части программы, отвечающей за парсеры. Парсер в P4 — это функция, которая отображает пакеты в заголовках и метаданные, написанные уже на языке конечного автомата.
![image](https://user-images.githubusercontent.com/64036217/196913283-f27f052d-1390-41a6-b206-207452ceea43.png)

12. Обращаемся к официальному cheat-sheet по P4. Там описан state start, обязательный для любого парсера, и далее описан как раз нужный нам parse_ethernet. Можем также заменить здесь select, который в P4 является аналогом case, и помогает ветвлению. Здесь он нам будет необходим, так как далее нужно прописать работу с ipv4 header.
![image](https://user-images.githubusercontent.com/64036217/196914017-409b8933-da93-433a-83d5-ddfacf7d4bdb.png)

13. Прописываем ethernet parser как указано в примере, далее самостоятельно дописываем часть, отвечающую за ipv4. 
![image](https://user-images.githubusercontent.com/64036217/196915354-733c0953-f717-4181-9bd6-3c5cd15706ae.png)

14. Checksum verification оставим как было изначально, здесь изменять что-либо нет необходимости.
![image](https://user-images.githubusercontent.com/64036217/196915657-2c175032-29e7-45c3-9353-075489b2bfb6.png)

15. Далее переходим к Ingress. Он отвечает за входящий трафик, и нужно описать, что именно с ним нужно делать.
![image](https://user-images.githubusercontent.com/64036217/196956994-d403490c-7276-4f0b-9bd1-20951f7231b9.png)

16. Нам необходимо поменять адрес получателя и отправителя местами, обновить ttl и отправить пакет обратно на порт. Прописываем это самостоятельно на P4.
![image](https://user-images.githubusercontent.com/64036217/196992024-2e6c858f-9078-40cb-bab9-08774396387a.png)

17. IPV4 table нам уже задано, поэтому просто проанализируем данный код. Прописывается таблица - это фундаментальная часть пайплайна. Она указывает, какие данные сопоставлять и каким образом, а также список действий. То есть таблица содержит правило, которое содержит в себе ключ сопоставления, действия, какие с ним можно совершать, а также размер и стандартное действие. 
![image](https://user-images.githubusercontent.com/64036217/196982565-4e4c941f-5450-4686-a0bd-bb6f75640842.png)

18. Прописываем пропущенное условие, которое проверяет правильность заголовка ipv4. Синтаксис здесь аналогичен с С++.
![image](https://user-images.githubusercontent.com/64036217/196983016-88822325-0153-4203-a140-8fd11631d876.png)

19. Egress нам тоже весь уже задан, здесь синтаксис аналогичен с ингресс, поэтому детально можно не останавливаться.
![image](https://user-images.githubusercontent.com/64036217/196983889-246c27e5-ae24-4bb1-ae43-c83170409614.png)

20. Функция по обновлению чексуммы нам тоже уже задана. Здесь проверяется корректность ip заголовка, задаются его запчасти, после чего вызывается уже заданная арнее функция генерации чексуммы.
![image](https://user-images.githubusercontent.com/64036217/196987514-20f36ed2-931c-443a-a3c6-ff4ba60082ae.png)

21. Теперь необходимо распарсить (?) всё происходящее обратно. Для этого вызываем функцию из p4.core, которая собирает заголовки обратно в сформированный пакет.
![image](https://user-images.githubusercontent.com/64036217/196990463-63c848e0-63b9-4a47-a21f-7e55139420d7.png)

22. Последняя часть программы, вызывающая все описанные ранее функции.
![image](https://user-images.githubusercontent.com/64036217/196990770-a5313d03-0b7b-466d-9a4f-a8800ce6666d.png)

23. Проверим, что всё работает, отправив пинг с h1 на h2 (схема сети выше). Видим, что теперь пинг идёт, следовательно всё настроено корректно.
![image](https://user-images.githubusercontent.com/64036217/196992230-917b9f1a-5bba-4f55-866e-b53b06675256.png)

24. Приступаем ко второй части лабораторной работы, а точнее выполнению задания по базовому туннелированию. То есть будет необходимо определить новый тип заголовка для инкапсуляции IP-пакета и изменить код коммутатора, чтобы он вместо этого определял порт назначения, используя новый заголовок туннеля. Новый тип заголовка будет содержать идентификатор протокола, указывающий тип инкапсулируемого пакета, а также идентификатор получателя, который будет использоваться для маршрутизации. Схема сети приложена. По второму изображению можно понять суть тунеллирования, то есть того, что будет нужно реализовать.
![image](https://user-images.githubusercontent.com/64036217/196998221-a11cb99e-ca99-42b6-81d3-24806f6c01e0.png)
![image](https://user-images.githubusercontent.com/64036217/197010140-2a9dcafe-c0ca-4bbb-975f-dece27d7c95e.png)


25. Используется та же виртуальная машина. Также во многом код повторяет предыдущую задачу, поэтому не буду акцентировать внимание на том, что было описано ранее. 

26. Была добавлена ещё одна константа, необходимая для туннелирования.
![image](https://user-images.githubusercontent.com/64036217/197022472-35581062-ca64-41ac-8eef-b8c784192c98.png)

27. Добавлен новый тип заголовка, включающий в себя id протокола и адреса назначения.
![image](https://user-images.githubusercontent.com/64036217/197026763-c0444ca2-4e9b-42c3-893d-bcc22149eac0.png)

28. В структуру заголовков добавлен описанный ранее тип.
![image](https://user-images.githubusercontent.com/64036217/197027047-d2e10fd4-a01c-4a4b-b63b-29b100e2e357.png)

29. Создаём ещё один стейт в парсерах, по аналогии с уже существующими ethernet и ipv4. Добавляем его в оператор select в ethernet, который идёт до него, и включаем в него оператор select, указываюший на ipv4. 
![image](https://user-images.githubusercontent.com/64036217/197027319-ed7bc0e0-42e1-469d-8b3e-6cf4238598d4.png)

30. Следующим пунктом в задаче является создать новое действие, myTunnel_forward(egressSpec_t port). Здесь нет необходимости изменять что-либо, как в предыдущий раз с mac адресами, поэтому будет достаточно указать порт в метадате.
![image](https://user-images.githubusercontent.com/64036217/197034611-f0209448-b8fd-4cb9-b32a-0e6d68a268e0.png)


31. Создаём таблицу, в которой ключ и действие прописываем те, что были созданы выше. В остальном она будет аналогична предыдущей по ipv4.
![image](https://user-images.githubusercontent.com/64036217/197034744-10c61bde-d814-4490-a5ae-e8b0da129192.png)

32. Прописываем условия проверки - если айпи задан верно, а туннель нет, то отправляем пакеты обычным способом, как в первой части работы, если задано верно всё, то отправляем через туннель.
![image](https://user-images.githubusercontent.com/64036217/197039723-9a40fb91-b803-4ceb-8696-bd171e288d74.png)

33. Не забываем добавить пункт про туннели в часть депарсинга.
![image](https://user-images.githubusercontent.com/64036217/197040087-e5c3af91-659d-4c88-9672-df29597450fb.png)


34. Теперь необходимо проверить, что всё написанное работает. Запускаем это командой make run и через мининет запускаем два мини терминальчика наших устройств.
![image](https://user-images.githubusercontent.com/64036217/197048235-2d6e62b2-8e52-4fe4-9ac7-44e5e49da958.png)

35. На h2 поднимаем сервер, после чего с h1 отправляем пакет на него.
![image](https://user-images.githubusercontent.com/64036217/197048644-f26eee87-3d64-4c5f-b343-f161191b2782.png)

36. Видим, что пакет дошёл до получателя.
![image](https://user-images.githubusercontent.com/64036217/197048763-b9ee03cf-dff5-4a4c-82d8-8cfe5425624f.png)

37. Благодаря туннелю, даже несмотря на указанный ip адрес h3, сообщение всё равно дошло до h2. Таким образом мы проверили, что всё сконфигурировано верно.
![image](https://user-images.githubusercontent.com/64036217/197049170-34537c04-3540-47ee-b515-be24f4105c90.png)

Выводы: Было детально разобрано стандартное перенаправление пакетов, а также туннелирование, и данные механизмы реализованы посредством языка P4.
